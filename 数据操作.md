## 操作mysql

```go
go get github.com/go-sql-driver/mysql 
go get github.com/jmoiron/sqlx   

// 连接
sqlx.Open("mysql", "root:123456@tcp(127.0.0.1:3306)/test")

// 插入
db.Exec("insert into person(username, sex, email)values(?, ?, ?)", "test1", "1", "test@qq.com")

// 查询
var person []Person
db.Select(&person, "select user_id, username, sex, email from person where user_id=?", 1)

// 更新
db.Exec("update person set username=? where user_id=?", "unminzzz", 1)

// 删除
db.Exec("delete from person where user_id=?", 1)

// 事务
db.Begin()
db.Commit()
db.Rollback()
```

## 操作redis

```go
go get github.com/gomodule/redigo/redis

// 连接
redis.Dial("tcp", "127.0.0.1:6379")

// get set string
conn.Do("set", "test", 100)
redis.Int(conn.Do("get", "test"))

conn.Do("setex", "test_string_expire", 60, "1")
redis.Int(conn.Do("ttl", "test_string_expire"))
redis.String(conn.Do("get", "test_string_expire"))

// set get strings
conn.Do("mset", "a", 100, "b", 200)
redis.Ints(conn.Do("mget", "a", "b"))

// expire
conn.Do("expire", "a", 10)

// list
conn.Do("lpush", "test_list", "a", "b", "c")
redis.String(conn.Do("lpop", "test_list"))
// c

// hash
conn.Do("hset", "test_hash", "abc", 100)
redis.Int(conn.Do("hget", "test_hash", "abc"))

// 命令参考
https://www.redis.net.cn/order/
```

```go
var pool *redis.Pool
pool = &redis.Pool{
	MaxIdle: 16,
	MaxActive: 1000,
  MaxActive:   0,
	IdleTimeout: 30,
	Dial: func() (redis.Conn, error) {
		return redis.Dial("tcp", "127.0.0.1:6379")
	},
}
```

## 操作etcd

```
	etcd是一个使用go语言开发的开源、高可用的分布式kv存储系统，可用于配制共享和服务的注册发现。
	etcd的特点：
	1. 完全复制，即群众的每个节点都可以使用完整的存档
	2. 高可用性，etcd可用于避免硬件的单点故障和网络问题
	3. 一致性，每次读取都会返回跨多主机的最新写入
	4. 简单，包含了一个定义良好、面向用户的API(gRPC)
	5. 安全，实现了带有可选的客户端证书验证的自动化TLS
	6. 快速，没秒10000次写入的基准速度
	7. 可靠，使用Raft算法实现了强一致性、高可用的服务存储目录
	
	etcd的应用场景
	1. 服务发现
	2. 配置中心
	3. 分布式锁，锁服务有两种方式，保持占用和控制时序，
```



```go
go get go.etcd.io/etcd/client/v3

// conn
client.New(clientv3.Config{
	Endpoints: []string{"127.0.0.1:2379"},
	DialTimeout: 5 * time.Second,
})

// put
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
cancel()
client.Put(ctx, "test_put", "hava_value_now")


// get
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
cancel()
resp, _ := client.Get(ctx, "test_put")
for _, ev := range resp.Keys {
	// ev.Keys
	// ev.Value
}

// watch
// <-chan 
rchan := client.Watch(context.Backgroud(), "test_watch")
for wrsp := range rchan {
  for _, ev := range wrsp.Events {
    // ev.Type
    // ev.Kv.Key
    // ev.Kv.Value
  }
}

// lease租约
resp, _ := client.Grant(context.TODO(), 5)
client.Put(context.TODO(), "test_lease", "have_value_now", clientv3.WithLease(resp.ID))

// keepAlive
resp, _ := client.Grant(context.TODO(), 5)
client.Put(context.TODO(), "test_lease", "have_value_now", clientv3.WithLease(resp.ID))
ch, _ := cli.KeepAlive(context.TODO(), resp.ID)
for {
	ka := <-ch
  fmt.Println("ttl:", ka.TTL)
}


// 基于etcd实现分布式锁
s1, _ := concurrency.NewSession(client)
defer s1.Close()
m1 := concurrency.NewMutex(s1, "/my-lock/")

s2, _ := concurrency.NewSession(client)
defer s2.Close()
m2 := concurrency.NewMutex(s2, "/my-lock/")

m1.Lock(context.TODO())
canLock := make(chan struct{})
go func() {
  // 关闭无缓冲通道，下面直接读不阻塞
  defer close(canLock)
  m2.Lock()
}
m1.UnLock(context.TODO())
<-canLock
```

## zookeeper

```go
// conn
zk.Connect([]string{"127.0.0.1:2181"}, time.Second*3)

// create
var flags int32 = 0
//flags有4种取值：
//0:永久，除非手动删除
//zk.FlagEphemeral = 1:短暂，session断开则改节点也被删除
//zk.FlagSequence  = 2:会自动在节点后面添加序号
//3 即，短暂且自动添加序号
conn.Create("/test_create", nil, flags, zk.WorldACL(zk.PermAll))
conn.Set("/test_create", nil, -1)
conn.Delete("/test_create", -1)
conn.Children("/")
```

```go
func main() {
	go startServer("127.0.0.1:18897")
	go startServer("127.0.0.1:18898")
	go startServer("127.0.0.1:18899")

	a := make(chan struct{})
	<-a
}

func startServer(url string) {
	listener, err := net.Listen("tcp", url)
	handleServerError(err, "listen tcp err: ")
	zkList := []string{"localhost:2181"}
	zkConn, _, err := zk.Connect(zkList, 10*time.Second)
	handleServerError(err, "conn zk err: ")
	defer zkConn.Close()
	zkConn.Create("/servers", nil, 0, zk.WorldACL(zk.PermAll))
	_, err = zkConn.Create("/servers/"+url, nil, zk.FlagEphemeral, zk.WorldACL(zk.PermAll))
	handleServerError(err, "create zk node err: ")
	defer zkConn.Close()

	for {
		tcpConn, err := listener.Accept()
		handleServerError(err, "accept tcp err: ")
		go handleClient(tcpConn, url)
	}

}

func handleClient(conn net.Conn, url string) {
	defer conn.Close()
	daytime := time.Now().String()
	conn.Write([]byte(url + ": " + daytime))
}

func handleServerError(err error, msg string) {
	if err != nil {
		log.Println(msg, err)
	}
}
```

```go
func main() {
	for i := 0; i < 100; i++ {
		startClient()
		time.Sleep(1 * time.Second)
	}
}

func startClient() {
	// service := "127.0.0.1:8899"
	zkConn, _, err := zk.Connect([]string{"localhost:2181"}, 10*time.Second)
	handleClientError(err, "conn zk err: ")
	defer zkConn.Close()
	serverList, _, err := zkConn.Children("/servers")
	handleClientError(err, "get zk list err: ")
	count := len(serverList)
	if count == 0 {
		err = errors.New("server list is empty \n")
		return
	}
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	serverHost := serverList[r.Intn(3)]
	log.Println("connect host: ", serverHost)

	tcpAddr, _ := net.ResolveTCPAddr("tcp4", serverHost)
	tcpConn, err := net.DialTCP("tcp", nil, tcpAddr)
	handleClientError(err, "conn tcp err: ")
	defer tcpConn.Close()
	log.Println("connect host success: ", serverHost)
	tcpConn.Write([]byte("timestamp"))

	result, err := ioutil.ReadAll(tcpConn)
	handleClientError(err, "get tcp data err: ")
	log.Println("get data: ", string(result))
	return
}

func handleClientError(err error, msg string) {
	if err != nil {
		log.Println(msg, err)
	}
}
```

## go操作kafka