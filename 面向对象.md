## 匿名字段

​	只提供类型而不写字段名

​	所有内置类型和自定义类型都可以作为匿名字段使用

## 接口

​	接口定义了一个对象 

### 接口的定义

```
1.接口是一个或多个方法签名的集合
2.任何类型的方法集中只要拥有该接口'对应的全部方法'签名，就表示它 "实现" 了该接口，无须在该类型上显式声明实现了哪个接口，这称为Structural Typing
3.所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。   当然，该类型还可以有其他方法
4.接口只有方法声明，没有实现，没有数据字段
5.接口可以匿名嵌入其他接口，或嵌入到结构中
6.对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针
7.只有当接口存储的类型和对象都为nil时，接口才等于nil
8.接口调用不会做receiver的自动转换
9.接口同样支持匿名字段方法
10.接口也可实现类似OOP中的多态
11.空接口可以作为任何类型数据的容器
12.一个类型可实现多个接口
13.接口命名习惯以 er 结尾
```

```
type 接口类型名 interface {
	方法名1 (参数列表1) 返回值列表1
	方法名2 (参数列表2) 返回值列表2
}
```

### 实现接口的条件

```
一个对象只要实现了接口中全部的方法，那么就实现了这个接口
```

### 值接收者和指针接收者实现接口的区别

```
用值接收者实现接口后，不管是结构体还是结构体指针类型的变量都可以赋值给该接口变量。
用指针接收者实现接口后，只能把结构体指针类型的变量赋值给该接口变量。
```

### 类型与接口的关系

- 一个类型可以同时实现多个接口窗口而彼此独立，不知道对方的实现

- 多个类型实现同一个接口，一个接口的方法不一定由一个类型完全实现，接口中的方法可以通过类型中嵌入其他类型或结构体实现
- 接口与接口嵌套可以创造出新的接口

### 空接口

​	空接口是指没有定义任何方法的接口，因此任何类型都实现了空接口

​	空接口类型的变量可以存储任意类型的变量

```
空接口作为函数参数可以接受任意类型的函数参数
空接口可以实现保存任意值的字典
```

### 类型断言

```
	一个接口值时由一个具体类型和具体类型的值两部分组成，这两部分分别称为接口的动态类型和动态值。

var w io.Writer
w = os.Stdout
动态类型*os.File 	动态值os.File
w = new(bytes.Buffer)
动态类型*bytes.Buffer		动态值bytes.BUffer
w = nil 
动态类型nil 	动态值nil

类型断言 x.(T)
x: 表示类型为interface{}	的变量
T: 表示断言x可能的类型
```

