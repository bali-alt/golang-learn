## Golang简介

### 优点

* 自带GC
* 静态编译
* 简单的思想，没有继承，多态，类等
* 丰富的库，详细的开发文档
* 语法层支持并发，拥有同步并发的channel类型
* 简单的语法
* 简单的交叉编译

### 主要特征

1. 自动立即回收
2. 丰富的内置类型
3. 函数多返回值
4. 错误处理
5. 匿名函数和闭包
6. 类型和接口
7. 并发编程
8. 反射
9. 语言交互性

### Go语言命名

1. Go的函数、变量、常量、自定义类型、包的命名方式遵循以下规则

   ```
   1）首字符可以是任意的Unicode字符或者下划线
   2）剩余字符可以是Unicode字符、下划线、数字
   3）字符长度不限
   ```

2. Go只有25个关键字

   ```
   break				default				func			interface		select
   case				defer					go				map					struct
   chan				else					goto			package			switch
   const				fallthrough		if				range				type
   continue		for						import		return			var
   ```

3. Go的37个保留关键字

   ```
   Constants:	true	fase	iota	nil
   
   Types:	int		int8		int16		int32		int64
   				uint	unit8		unit16	uint32	unit64
   				float32	float64	complex128	complex64
   				bool	byte		rune		string		error
   				
   Functions:	make	len		cap		new		append	cpoy	close
   						delete	complex		real	imag	panic recover
   ```

4. 可见性

   ```
   1）声明在函数内部，是函数的本地值，类似private
   2）声明在函数外部，是对当前包可见的全局值，类似protect
   3）声明在函数外部且首字母大写是所有包可见的全局值，类似public
   ```

### Go语言声明

有四种主要声明方式：

```
var		const		type		func
```

Go的程序是保存在多个.go文件中，文件的第一行就是package 声明，用来说明该文件属于哪个包

## 内置类型

### 值类型

```
bool
int, int8, int16, int32, int64
uint, unit8, uint16, uint32, uint64
float32, float64
string
complex64, cpmples128
array		--固定长度的数组
```

### 引用类型

```
slice		-- 序列数组
map			-- 映射
chan		-- 管道
```

## 内置类型

```
append			-- 追加元素到数组、slice中，返回修改后的数组、slice
close				-- 关闭channel
delete			-- 从map中删除key对应的value
panic				-- 停止常规的goroutine
recover			-- 捕获panic
real				-- 返回是复数的实部
imag				-- 返回复数的虚部
make				-- 分配内存，用于slice map channel
new					-- 分配内存，用于值类型
cap					-- 返回最大容量
copy				-- 用于复制和连接slice，返回复制的数目
len					-- 求长度
print,println	-- 底层打印函数
```

## 内置接口error

```go
type error interface {
  Error() string
}
```

## init 函数

```
1.init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
2.每个包可以拥有多个init函数
3.包的每个源文件也可以拥有多个init函数
4.同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)
5.不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序
6.init函数不能被其他函数调用，而是在main函数执行之前，自动被调用
```

## main函数和init函数的异同

```
相同点：
	两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
不同点：
	init可以应用于任意包中，且可以重复定义多个。
	main函数只能用于main包中，且只能定义一个。
```

## 运算符

### 算数运算符

| 运算符 | 描述 |
| ------ | ---- |
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |

> ++和--在go语言中是单独的语句，并不是运算符

### 关系运算符

| 运算符 | 描述                         |
| ------ | ---------------------------- |
| ==     | 检查两个值是否相等           |
| !=     | 检查两个值是否不相等         |
| >      | 检查左边值是否大于右边值     |
| >=     | 检查左边值是否大于等于右边值 |
| <      | 检查左边值是否小于右边值     |
| <=     | 检查左边值是否小于等于右边值 |

###  逻辑运算符

| 运算符 | 描述    |
| ------ | ------- |
| &&     | 逻辑AND |
| \|\|   | 逻辑OR  |
| !      | 逻辑NOT |

### 位运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 参与运算的两数各对应的二进位相与。（两位均为1才为1）         |
| \|     | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1）     |
| ^      | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1） |
| <<     | 左移n位就是乘以2的n次方。“a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
| >>     | 右移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位。  |

### 赋值运算符

| 运算符 | 描述                                           |
| :----- | :--------------------------------------------- |
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
| +=     | 相加后再赋值                                   |
| -=     | 相减后再赋值                                   |
| *=     | 相乘后再赋值                                   |
| /=     | 相除后再赋值                                   |
| %=     | 求余后再赋值                                   |
| <<=    | 左移后赋值                                     |
| >>=    | 右移后赋值                                     |
| &=     | 按位与后赋值                                   |
| l=     | 按位或后赋值                                   |
| ^=     | 按位异或后赋值                                 |

## 下划线

​	"_"是特殊标识符，用来忽略结果

### 下划线在import中

​	用【import _ 包路径】只是引用该包，仅仅是为了调用init()函数

### 下划线在代码中

​	忽略这个变量

## 变量

### 标准声明

```
var 变量名 变量类型

var name string
var age int
var isOk bool
```

### 批量声明

```
var (
	a string
	b int
	c bool
	d float32
)
```

### 变量初始化

```
Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值

var 变量名 类型 = 表达式
var name, sex = "cn", 1
```

#### 类型推导

```
var name = "pprof.cn"
var sex = 1
```

#### 短变量、匿名变量

## 常量

```
const pi = 3.1415
const e = 2.7182

const (
  pi = 3.1415
  e = 2.7182
)

const (
  n1 = 100
  n2
  n3
)
// n1,n2,n3都是100
```

### iota

iota是go语言的常量计数器，在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次，iota可以理解为cons语句块的行索引。

## 基本类型介绍

| 类型          | 长度(字节) | 默认值 | 说明                                      |
| :------------ | :--------- | :----- | :---------------------------------------- |
| bool          | 1          | false  |                                           |
| byte          | 1          | 0      | uint8                                     |
| rune          | 4          | 0      | Unicode Code Point, int32                 |
| int, uint     | 4或8       | 0      | 32 或 64 位                               |
| int8, uint8   | 1          | 0      | -128 ~ 127, 0 ~ 255，byte是uint8 的别名   |
| int16, uint16 | 2          | 0      | -32768 ~ 32767, 0 ~ 65535                 |
| int32, uint32 | 4          | 0      | -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 |
| int64, uint64 | 8          | 0      |                                           |
| float32       | 4          | 0.0    |                                           |
| float64       | 8          | 0.0    |                                           |
| complex64     | 8          |        |                                           |
| complex128    | 16         |        |                                           |
| uintptr       | 4或8       |        | 以存储指针的 uint32 或 uint64 整数        |
| array         |            |        | 值类型                                    |
| struct        |            |        | 值类型                                    |
| string        |            | “”     | UTF-8 字符串                              |
| slice         |            | nil    | 引用类型                                  |
| map           |            | nil    | 引用类型                                  |
| channel       |            | nil    | 引用类型                                  |
| interface     |            | nil    | 接口                                      |
| function      |            | nil    | 函数                                      |

### 整型

​	整型分为以下两种类型：按长度分为`int8`, `int16`, `int32`, `int64`对应的无符号整型：`uint8`, `uint16`, `uint32`, `uint64`。`uint8`就是`byte`型，`int16`对应C语言中的`short`型，`int64`对应C语言中的`long`型。

### 浮点型

​	Go语言支持两种浮点数，`float32`, `float64`。

​	`math.MaxFloat32`, `math.MaxFloat64`

### 复数

​	`complex64`和`complex128`。复数有实部和虚部，`complex64`的实部和虚部为32位，`complex128`的实部和虚部为64位

### 布尔值

Go语言中以bool类型声明布尔类型数据，只有true和false

### 字符串

Go语言中的字符串以原生数据类型出现，默认UTF-8

### 字符串转义

| 转义 | 含义                               |
| ---- | ---------------------------------- |
| \r   | 回车符（返回行首）                 |
| \n   | 换行符（直接跳到下一行的同列为值） |
| \t   | 制表符                             |
| `    | 单引号                             |
| "    | 双引号                             |
| \    | 反斜杠                             |

### 多行字符串

```
s1 := `第一行
第二行
`

文本原样输出
```

### 字符串的常用操作

| 方法                                 | 介绍           |
| ------------------------------------ | -------------- |
| len(str)                             | 求长度         |
| + fmt.Sprintf                        | 拼接字符串     |
| strings.Split                        | 分割           |
| strings.Contains                     | 判断是否包含   |
| strings.HasPrefix, strings.HasSuffix | 前缀后缀判断   |
| strings.Index(), strings.LastIndex() | 子串出现的位置 |
| strings.Join(a []string, sep string) | join操作       |

### byte和rune类型

​	组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。字符用单引号包裹起来。

```
var a := '中'
var b := 'x'
```

​	Go语言的字符有两种，uint8，代表一个ASCII码，也可以叫byte；rune类型，代表一个UTF-8字符

```go
// 遍历字符串
func traversalString() {
  s := "博客"
  for i := 0; i < len(s); i++ { //byte
    fmt.Printf("%v(%c) ", s[i], s[i])
  }
  fmt.Println()
  for _, r := range s { //rune
    fmt.Printf("%v(%c) ", r, r)
  }
  fmt.Println()
}

// 229(å) 141() 154() 229(å) 174(®) 162(¢)
// 21338(博) 23458(客)
```

### 修改字符串

```go
func changeString() {
  s1 := "hello"
  // 强制类型转换
  byteS1 := []byte(s1)
  byteS1[0] = 'H'
  fmt.Println(string(byteS1))

  s2 := "博客"
  runeS2 := []rune(s2)
  runeS2[0] = '狗'
  fmt.Println(string(runeS2))
}

// 要修改字符串，需要先转成[]rune或者[]byte，完成之后再转成string
```

### 类型转换

Go语言只有强类型转换，没有隐式类型转换。

```
T(表达式)
```

## 数组Array

```
1.数组：是同一种数据类型的固定长度的序列
2.数组定义：var a [len]int 数组的长度必须是常量，确实数组类型的一部分，一旦确定，长度不会变
3.长度是数组类型的一部分，var a [5]int和var a [10]int是不同的类型
4.数组可以用下标访问
5.数组越界会触发器panic
6.数组是指类型，赋值和传参会复制整个数组，而不是指针
7.支持 "==" "!=" 操作，因为内存总是被初始化过的
8.[n]*T指针数组，*[n]T数组指针
```

### 数组初始化

#### 一维数组

```go
// 全局
var arr0 [5]int = [5]int{1,2,3}
var arr1 = [5]int{1,2,3,4,5}
var arr2 = [...]int{1,2,3,4,5,6}
var arr4 = [5]string{3:"hello",4:"go"}

// 局部变量
a := [3]int{1,2} // 未初始化元素值为 0。
b := [...]int{1,2,3,4} // 通过初始化值确定数组长度。
c := [5]int{2:100,4:200} // 使用引号初始化元素
d := [...]struct{
  name string
  age uint8
}{
  {"user1", 10},
  {"user2", 20}, // 逗号
}

```

#### 多维数组

```go
// 全局
var arr0 [5][3]int
var arr1 [2][3]int = [...][3]int{[1,2,3], [7,8,9]}

// 局部
a := [2][3]int{{1,2,3}, {4,5,6}}
b := [...][2]int{{1,2}, {3,4}, {5,6}}
```

> 值拷贝行为会造成性能问题，使用slice或者数组指针
>
> 内置的len cap都可以用在数组上

## 切片slice

```
1.切片：切片是数组的一个引用，因为切片是引用类型。但自身是结构体，值拷贝传递
2.切片的长度可以改变，因此，切片是一个可变的数组
3.切片遍历方式和数组一样，可以用len()求长度，表示可用元素数量，读写操作不应该超过该限制
4.cap可以求slice最大扩张问题，不能超出数组限制。0 <= len(slice) <= len(array) 其中array是alice应用的数组
5.切片的定义 	var 变量名 []类型 
6.如果slice == nil 那么len, cap 都是0
```

### 切片创建

```
var s1 []int
s2 := []int{}
var s3 = make([]int, 0)
var s4 = make([]int, 0, 0)
s5 := []int{1,2,3,4,5}
s6 := arr[1:4]
```

### 切片初始化

```
全局：
var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
var slice0 []int = arr[start:end] 
var slice1 []int = arr[:end]        
var slice2 []int = arr[start:]        
var slice3 []int = arr[:] 
var slice4 = arr[:len(arr)-1]      //去掉切片的最后一个元素
局部：
arr2 := [...]int{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
slice5 := arr[start:end]
slice6 := arr[:end]        
slice7 := arr[start:]     
slice8 := arr[:]  
slice9 := arr[:len(arr)-1] //去掉切片的最后一个元素
```

> 超出slice.cap限制后 会重新分配底层数组
>
> copy 复制的长度以len小的为准
>
> string底层就是一个byte的数组，因此可以进行切片操作

### 切片冒号的理解

> 常规slice，data[6:8]，从第6位到第8位，长度len为2，cap为9-6=4
>
> 另一种写法：data[:6:8] 每个数字前都有毛好，slice内容为data从0到6的位置，长度为6，cap=8
>
> a[x:y:z] 切片内容[x:y] 长度y-x 容量z-x

### 数组、切片转字符串

```go
strings.Replace(strings.Trim(fmt.Sprint(array_or_slice), "[]"), " ", ",", -1)
```

## Slice底层实现

```
	切片本身不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写限定在指定的区域内，其本身是一个只读对象。
	
	make函数允许在运行期间动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。
	
	空切片和nil切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但它没有分配任何内存空间，即基层元素包含0个元素。
	
	切片扩容的策略是：如果切片的容量小于1024个，扩容时翻倍。如果超过1024个，那么增常因子就变成1.25	
	
	使用字面量创建切片的时候，cap值一定要清晰 slice:=array[1:2:3]
	
	使用range的方式去遍历切片的时候，拿到的value实际上切片的值拷贝，其内存地址不变，需要用过&slice[index]获取真实的地址
```

## 指针

> &取地址  *根据地址取值

### 指针地址和指针类型

​	Go语言的值类型都有对应的指针类型。

```
ptr := &v    // v的类型为T

// v: 代表被取地址的变量，类型为T
// ptr: 用于接收地址的变量，ptr的类型就为*T，称作T的指针类型。
```

### 指针取值

```
	取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值。
	
	变量、指针地址、指针变量、取地址、取值的相互关系和特征如下
	1. 对变量进行取值&操作，可以或者这个变量的指针变量
	2. 指针变量的值时指针地址
	3. 对指针变量进行取值*操作，可以获得指针变量指向的原变量的值
```

### 空指针

```
当一个指针被定义后没有分配到任何变量时，它的值时nil
空指针用 p == nil判断
```

> 在Go中，对于引用类型的变量，使用的时候不仅要申明，还要为他分配内存空间。对于值类型的变量不需要分配内存空间，因为它们在生命的时候已经默认分配好了内存空间。

### new

```
new是一个内置函数，函数签名 func new(Type) *Type
1. Type表示类型，new函数只接受一个参数，这个参数是一个类型
2. *Type表示类型指针，new函数返回一个只想改类型内存地址的指针
```

### make

```
make只用于slice、map、chan的内存创建，它返回的类型就是这三个类型本身，而不是他们的指针类型。因为这三种类型就是引用类型。
```

### make和new的区别

```
1. 二者都是用来做内存分配的
2. make只适用于slice、map、channel的初始化，返回的还是这三个引用类型本身
3. new用于类型的内存分配，并且内存对应的值的类型为零值，返回的是只想类型的指针
```

## Map

```
map是一种无序的基于key-value的数据类型，GO语言中的map是引用类型，必须初始化才能使用

map的定义 map[KeyType]ValueType
map类型的变量默认值为nil，需要使用make函数进行分配内存

make(map[KeyType]ValueType, [cap])
cap表示map的容量，该参数虽然不是必须的，但是应该咋初始化的时候就为其指定合适的的容量
```

### 判断键是否存在

```
value, ok := map[key]
```

### map遍历

```
for range	遍历顺序与添加顺序无关
```

### delete删除键值对

```
delete(map, key)
```

### 指定顺序遍历map

```
先把map的key取出来，再排序，再按照key取
```

##  Map实现原理

```
	通俗的说，map就是一种通过key获取value的一个数据结构，其底层存储方式为数组，当key重复时，value会进行覆盖。对key进行hash运算，然后对其数组的长度取余，得到key存储在数组的哪个下标位置，最后把key和value组成结构体，放入数组下标处
```

### hash冲突

```
	数组一个下标只能存储一个元素，当hashkey重复时，就出现了hash冲突。
	
	开放定址法：当hash冲突时，在数组中间重新找一个没有被占用的存储这个key。有线性探测法，线性补偿探测法，随机探测法...
	线性探测法：从冲突的下标开始往后探测，到达数组末尾时，从数组开始出探测。
	
	拉链法：key的hash冲突时，在冲突位置形成一个链表，通过指针互相连接
	
开放定址（线性探测）和拉链的优缺点
1. 拉链法较为简单
2. 线性探测会消耗更多时间
3. 线性探测更加容易扩容
4. 拉链存储了指针，因此空间占用多一点
5. 拉链时动态申请内存的，所以更时候链长不确定的
```

### Go中map的实现原理

```
	使用数组存储，每个数组下标处存储的是一个bucket，每个bucket可以存储8个kv对，当kv存储8个以上后，会通过overflow指针指向一个新的bucket，从而形成链表。
	bucket中，通过tophash快速查找key值是否在该bucket中
```

## 结构体

### 类型别名和自定义类型

```
// 自定义类型
type MyInt int
```

```
// 类型别名
type MyInt = int
```

```
区别
	自定义类型在编译完成时会存在
	类型别名只在代码中存在，编译完成后不存在。
```

> Go通过struc来实现面向对象

### 结构体的定义

```
type 类型名 struct {
	字段名 字段类型
}
```

### 结构体实例化

​	只有当结构体实例化时，才会真正地分配内存。结构体本身也是一种类型，可以使用var关键字声明结构体类型

```
var 结构体实例 结构体类型
```

### 匿名实例化

```
 var user struct{Name string; Age int}
 user.Name = "pprof.cn"
 user.Age = 18
```

### 创建指针类型结构体

​	使用new关键字对结构体进行实例化，得到的是结构体的地址。Go语言支持对结构体指针直接使用.来访问结构体的成员

### 取结构体的地址实例化

```
使用&对结构体进行取址操作相当于对结构体进行了一次new操作

p := &person{}
```

> 可使用键值对初始化，也可以简化使用值初始化

### 构造函数

​	Go语言的结构体没有构造函数，可以自己实现，返回结构体指针

### 方法接收者

​	Go语言中的方法是一种作用于特定类型变量的函数，这种特定类型变量叫接收者。类似于this

```
type (接收者变量 接收者类型) 方法名(参数)(返回参数){
	函数体
}
```

> 指针类型的接收者的修改是有效的
>
> 值类型的接收者会复制值

### 结构体的匿名字段

​	结构体允许其成员字段在声明时没有字段名而只是类型

​	一个结构体中筒中类型的匿名字段只能有一个

### 结构体嵌套

> 结构体的继承可以使用嵌套的方式

### 结构体字段可见性

​	结构体中字段大写开头表示公开访问，小写表示私有访问

### 结构体和JSON序列化

```
json.Marshal()
json.Unmarshal()
```

### 结构体标签

```
tag 是结构体的原信息，可以在运行的时候通过反射的机制读取出来

`key1:"value1" key2:"value2"`
```

